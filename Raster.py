#!/bin/env python
svnUrl = '$HeadURL: svn+ssh://hon@honsys.com/var/svnroot/ogcwms/trunk/pydocs/Raster.py $'
svnId = rcsId = '$Name$ $Id: Raster.py 24 2008-04-01 06:19:16Z hon $'
#
import os, sys
import FileKeyUtils
from PIL import Image
from vipsCC import *
#
#"""@package docstring
__doc__ = _modinfo = \
"""
The Raster module provides support for different resolution BMNG datasets: 8km, 2km, and 500m.
Tiles can be generated by extracting an arbitrary bbox from BMNGfile(s) and resizing to the desired
tile size.
"""
#

# globals
_Xpixcnt = {'BMNG500m':21600, 'BMNG2km':21600, 'BMNG8km':5400}
_Xpixmax = {'BMNG500m':_Xpixcnt['BMNG500m']- 1, 'BMNG2km':_Xpixcnt['BMNG2km']- 1, 'BMNG8km':_Xpixcnt['BMNG8km']- 1}
_Xdegpix = {'BMNG500m':90.0/_Xpixmax['BMNG500m'], 'BMNG2km':360.0/_Xpixmax['BMNG2km'], 'BMNG8km':360.0/_Xpixmax['BMNG8km']}
_Xpixdeg = {'BMNG500m':_Xpixmax['BMNG500m']/90.0, 'BMNG2km':_Xpixmax['BMNG2km']/360.0, 'BMNG8km':_Xpixmax['BMNG8km']/360.0}

_Ypixcnt = {'BMNG500m':21600, 'BMNG2km':10800, 'BMNG8km':2700}
_Ypixmax = {'BMNG500m':_Ypixcnt['BMNG500m']- 1, 'BMNG2km':_Ypixcnt['BMNG2km']- 1, 'BMNG8km':_Ypixcnt['BMNG8km']- 1}
_Ydegpix = {'BMNG500m':90.0/_Ypixmax['BMNG500m'], 'BMNG2km':180.0/_Ypixmax['BMNG2km'], 'BMNG8km':180.0/_Ypixmax['BMNG8km']}
_Ypixdeg = {'BMNG500m':_Ypixmax['BMNG500m']/90.0, 'BMNG2km':_Ypixmax['BMNG2km']/180.0, 'BMNG8km':_Ypixmax['BMNG8km']/180.0}

_pixcnt = 21600 # for use in 500m BMNG logic

_BMNGpath       = '/devstore/GIS/BMNG/world_'
_BMNGwinter500m = _BMNGpath + '500m/world.topo.bathy.200401.3x21600x21600'
_BMNGsummer500m = _BMNGpath + '500m/world.topo.bathy.200407.3x21600x21600'
_BMNGwinter2km  = _BMNGpath +  '2km/world.topo.bathy.200401.3x21600x10800'
_BMNGsummer2km  = _BMNGpath +  '2km/world.topo.bathy.200407.3x21600x10800'
_BMNGwinter8km  = _BMNGpath +  '8km/world.topo.bathy.200401.3x5400x2700'
_BMNGsummer8km  = _BMNGpath +  '8km/world.topo.bathy.200407.3x5400x2700'


# note deg. bbox convention: [lower-left-lon, lower-left-lat, upper-right-lon, uppoer-right-lat]
_bboxdeglist = {
'A1':[-180.0,   0.0, -90.0, 90.0],
'A2':[-180.0, -90.0, -90.0,  0.0],
'B1':[ -90.0,   0.0,   0.0, 90.0],
'B2':[ -90.0, -90.0,   0.0,  0.0],
'C1':[   0.0,   0.0,  90.0, 90.0],
'C2':[   0.0, -90.0,  90.0,  0.0],
'D1':[  90.0,   0.0, 180.0, 90.0],
'D2':[  90.0, -90.0, 180.0,  0.0]}

_bboxdegdict = {
'A1':{'BL':[-180.0,   0.0], 'BR':[-90.0,   0.0], 'TL':[-180.0, 90.0], 'TR':[-90.0, 90.0]},
'A2':{'BL':[-180.0, -90.0], 'BR':[-90.0, -90.0], 'TL':[-180.0,  0.0], 'TR':[-90.0,  0.0]},
'B1':{'BL':[ -90.0,   0.0], 'BR':[  0.0,   0.0], 'TL':[ -90.0, 90.0], 'TR':[  0.0, 90.0]},
'B2':{'BL':[ -90.0, -90.0], 'BR':[  0.0, -90.0], 'TL':[ -90.0,  0.0], 'TR':[  0.0,  0.0]},
'C1':{'BL':[   0.0,   0.0], 'BR':[ 90.0,   0.0], 'TL':[   0.0, 90.0], 'TR':[ 90.0, 90.0]},
'C2':{'BL':[   0.0, -90.0], 'BR':[ 90.0, -90.0], 'TL':[   0.0,  0.0], 'TR':[  0.0, 90.0]},
'D1':{'BL':[  90.0,   0.0], 'BR':[180.0,   0.0], 'TL':[  90.0, 90.0], 'TR':[180.0, 90.0]},
'D2':{'BL':[  90.0, -90.0], 'BR':[180.0, -90.0], 'TL':[  90.0,  0.0], 'TR':[180.0,  0.0]}
}

# pix. bbox convention: [bottom-left-x = 0, bottom-left-y = _pixcnt, top-right-x = _pixcnt, top-right-y = 0 ]
_bboxpixlist = [0.0, _pixcnt, _pixcnt, 0.0]
_bboxpixdict = {'BL':[0.0, _pixcnt], 'BR':[_pixcnt, _pixcnt], 'TL':[0.0, 0.0], 'TR':[_pixcnt, 0.0]}

##################################3################# module globals:  
# high res. (very large) BMNG files should only be loaded once -- as globals
_BMNG8kmFiles = {}; _BMNG8kmPImgs = {}; _BMNG8kmVImgs = {}
_BMNG2kmFiles = {}; _BMNG2kmPImgs = {}; _BMNG2kmVImgs = {}
_BMNG500mFiles = {}; _BMNG500mPImgs = {}; _BMNG500mVImgs = {}

##################################3################# module funcs:
#
def chooseRes(bbox, tilesize):
  print  >> FileKeyUtils.WMSlog, 'Raster.chooseRes> tilesize:', tilesize
  if len(bbox) <= 3:
    print  >> FileKeyUtils.WMSlog, 'Raster.chooseRes> use 8km default due to bad bbox:', bbox
    return 'BMNG8km'
 
  xpixcnt = _Xpixdeg['BMNG8km']*(bbox[2] - bbox[0])
  ypixcnt = _Ypixdeg['BMNG8km']*(bbox[3] - bbox[1])
  if tilesize[0] < xpixcnt and tilesize[1] < ypixcnt :
    print  >> FileKeyUtils.WMSlog, 'Raster.chooseRes> BMNG8km:', xpixcnt, ypixcnt
    return 'BMNG8km'

  xpixcnt = _Xpixdeg['BMNG2km']*(bbox[2] - bbox[0])
  ypixcnt = _Ypixdeg['BMNG2km']*(bbox[3] - bbox[1])
  if tilesize[0] < xpixcnt and tilesize[1] < ypixcnt :
    print  >> FileKeyUtils.WMSlog, 'Raster.chooseRes> BMNG2km:', xpixcnt, ypixcnt
    return 'BMNG2km'

  print  >> FileKeyUtils.WMSlog, 'Raster.chooseRes> BMNG500m:', xpixcnt, ypixcnt
  return 'BMNG500m'

def use8km(bbox, tilesize):
  res = chooseRes(bbox, tilesize)
  if res == 'BMNG8km':
    return True

  return False

def use2km(bbox, tilesize):
  res = chooseRes(bbox, tilesize)
  if res == 'BMNG2km':
    return True

  return False

def use500m(bbox, tilesize):
  res = chooseRes(bbox, tilesize)
  if res == 'BMNG2km' or res == 'BMNG8km' :
    return False

  return True

# these should perform a one-time open of the BMNGs as PIL Images
def initBMNG8kmPImgs():
  """
  Need only be invoked once to populate the global _BMNG8km{Files,Imgs}
  hash dicts. Invocation of this is mutually exclusive with all other resolutionas.
  Subsequent to initialization of the 8km hash dicts. (for the duration of the process),
  all BMNG tile rendering will make use of the 8km, 2km, or 500m  resolution data. Currently only
  two keys are supported: SummerBMNG and WinterBMNG.
  """
  global _BMNG8kmFiles
  global _BMNG8kmPImgs
  nimg = len(_BMNG8kmPImgs)
  if nimg > 0 :
    print >> FileKeyUtils.WMSlog, 'Raster.initBMNG8kmPImgs>', _BMNG8kmPImgs.keys()
    return nimg
# for month in ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'] :
#   _BMNG8kmFiles[month] = FileKeyUtils.BMNG8kmStore+'world.topo.bathy.2004'+month+'.3x5400x2700.tif'
# just winter and summer:
  _BMNG8kmFiles['SummerBMNG'] = FileKeyUtils.BMNG8kmStore+'world.topo.bathy.200407.3x5400x2700.tif'
  _BMNG8kmFiles['WinterBMNG'] = FileKeyUtils.BMNG8kmStore+'world.topo.bathy.200401.3x5400x2700.tif'
  for k in _BMNG8kmFiles.keys() :
    pimg = Image.open(_BMNG8kmFiles[k]) #; aimg = img.putalpha(255) ; del img
    _BMNG8kmPImgs[k] = img # aimg

# aliases (hardcoded for now):
  _BMNG8kmPImgs['Summer'] = _BMNG8kmPImgs['SummerBMNG'] 
  _BMNG8kmPImgs['Winter'] = _BMNG8kmPImgs['WinterBMNG'] 

  print >> FileKeyUtils.WMSlog, 'Raster.initBMNG8kmPImgs>', _BMNG8kmPImgs.keys()
  return len(_BMNG8kmPImgs)

def initBMNG2kmPImgs():
  """
  Need only be invoked once to populate the global _BMNG2km{Files,Imgs}
  hash dicts. Invocation of this is mutually exclusive with all other resolutionas.
  Subsequent to initialization of the 2km hash dicts. (for the duration of the process),
  all BMNG tile rendering will make use of the 8km, 2km, or 500m  resolution data. Currently only
  two keys are supported: SummerBMNG and WinterBMNG.
  """
  global _BMNG2kmFiles
  global _BMNG2kmPImgs
  nimg = len(_BMNG2kmPImgs)
  if nimg > 0 :
    print >> FileKeyUtils.WMSlog, 'Raster.initBMNG2kmPImgs>', _BMNG2kmPImgs.keys()
    return nimg
# for month in ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'] :
#   _BMNG2kmFiles[month] = FileKeyUtils.BMNG2kmStore+'world.topo.bathy.2004'+month+'.3x21600x10800.tif'
# just winter and summer:
  _BMNG2kmFiles['SummerBMNG'] = FileKeyUtils.BMNG2kmStore+'world.topo.bathy.200407.3x21600x10800.tif'
  _BMNG2kmFiles['WinterBMNG'] = FileKeyUtils.BMNG2kmStore+'world.topo.bathy.200401.3x21600x10800.tif'

  for k in _BMNG2kmFiles.keys() :
    pimg = Image.open(_BMNG2kmFiles[k]) #; aimg = img.putalpha(255) ; del img
    _BMNG2kmPImgs[k] = pimg # aimg
  
# aliases (hardcoded for now):
  _BMNG2kmPImgs['Summer'] = _BMNG2kmPImgs['SummerBMNG'] 
  _BMNG2kmPImgs['Winter'] = _BMNG2kmPImgs['WinterBMNG'] 

  print >> FileKeyUtils.WMSlog, 'Raster.initBMNG2kmPImgs>', _BMNG2kmPImgs.keys()
  return len(_BMNG2kmPImgs)

# these should perform a one-time open of the BMNGs as VIPS Images
def initBMNG8kmVImgs():
  """
  Need only be invoked once to populate the global _BMNG8km{Files,Imgs}
  hash dicts. Invocation of this is mutually exclusive with all other resolutionas.
  Subsequent to initialization of the 8km hash dicts. (for the duration of the process),
  all BMNG tile rendering will make use of the 8km, 2km, or 500m resolution data. Currently only
  two keys are supported: SummerBMNG and WinterBMNG.
  """
  global _BMNG8kmFiles
  global _BMNG8kmVImgs
  nimg = len(_BMNG8kmVImgs)
  if nimg > 0 :
    print >> FileKeyUtils.WMSlog, 'Raster.initBMNG8kmVImgs>', _BMNG8kmVImgs.keys()
    return nimg
# for month in ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'] :
#   _BMNG8kmFiles[month] = FileKeyUtils.BMNG8kmStore+'world.topo.bathy.2004'+month+'.3x5400x2700.tif'
# just winter and summer:
  _BMNG8kmFiles['SummerBMNG'] = FileKeyUtils.BMNG8kmStore+'world.topo.bathy.200407.3x5400x2700.tif'
  _BMNG8kmFiles['WinterBMNG'] = FileKeyUtils.BMNG8kmStore+'world.topo.bathy.200401.3x5400x2700.tif'
  for k in _BMNG8kmFiles.keys() :
    vimg = VImage.VImage(_BMNG8kmFiles[k]) #; aimg = img.putalpha(255) ; del img
    _BMNG8kmVImgs[k] = vimg # aimg
  
# aliases (hardcoded for now):
  _BMNG8kmVImgs['Summer'] = _BMNG8kmVImgs['SummerBMNG'] 
  _BMNG8kmVImgs['Winter'] = _BMNG8kmVImgs['WinterBMNG'] 

  print >> FileKeyUtils.WMSlog, 'Raster.initBMNG8kmVImgs>', _BMNG8kmVImgs.keys()
  return len(_BMNG8kmVImgs)

def initBMNG2kmVImgs():
  """
  Need only be invoked once to populate the global _BMNG2km{Files,Imgs}
  hash dicts. Invocation of this is mutually exclusive with all other resolutionas.
  Subsequent to initialization of the 2km hash dicts. (for the duration of the process),
  all BMNG tile rendering will make use of the 8km, 2km or 500m resolution data. Currently only
  two keys are supported: SummerBMNG and WinterBMNG.
  """
  global _BMNG2kmFiles
  global _BMNG2kmVImgs
  nimg = len(_BMNG2kmVImgs)
  if nimg > 0 :
    print >> FileKeyUtils.WMSlog, 'Raster.initBMNG2kmVImgs>', _BMNG2kmVImgs.keys()
    return nimg
# for month in ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'] :
#   _BMNG2kmFiles[month] = FileKeyUtils.BMNG2kmStore+'world.topo.bathy.2004'+month+'.3x21600x10800.tif'
# just winter and summer:
  _BMNG2kmFiles['SummerBMNG'] = FileKeyUtils.BMNG2kmStore+'world.topo.bathy.200407.3x21600x10800.tif'
  _BMNG2kmFiles['WinterBMNG'] = FileKeyUtils.BMNG2kmStore+'world.topo.bathy.200401.3x21600x10800.tif'

  for k in _BMNG2kmFiles.keys() :
    vimg = VImage.VImage(_BMNG2kmFiles[k]) #; aimg = img.putalpha(255) ; del img
    _BMNG2kmVImgs[k] = vimg # aimg
  
# aliases (hardcoded for now):
  _BMNG2kmVImgs['Summer'] = _BMNG2kmVImgs['SummerBMNG'] 
  _BMNG2kmVImgs['Winter'] = _BMNG2kmVImgs['WinterBMNG'] 

  print >> FileKeyUtils.WMSlog, 'Raster.initBMNG2kmVImgs>', _BMNG2kmVImgs.keys()
  return len(_BMNG2kmVImgs)

def initBMNG500mVImgs():
  """
  Need only be invoked once to populate the global _BMNG2km{Files,Imgs}
  hash dicts. Invocation of this is mutually exclusive with all other resolutionas.
  Subsequent to initialization of the 500m hash dicts. (for the duration of the process),
  all BMNG tile rendering will make use of the 8km, 2km or 500m resolution data. Currently only
  two keys are supported: SummerBMNG and WinterBMNG.
  """
  global _BMNG500mFiles
  global _BMNG500mVImgs
  nimg = len(_BMNG500mVImgs)
  if nimg > 0 :
    return nimg

  _BMNG500mFiles['SummerBMNG'] = {'A1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.A1.tif',
                                  'A2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.A2.tif',
                                  'B1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.B1.tif',
                                  'B2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.B2.tif',
                                  'C1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.C1.tif',
                                  'C2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.C2.tif',
                                  'D1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.D1.tif',
                                  'D2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200407.3x21600x10800.D2.tif'}
  _BMNG500mFiles['WinterBMNG'] = {'A1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.A1.tif',
                                  'A2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.A2.tif',
                                  'B1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.B1.tif',
                                  'B2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.B2.tif',
                                  'C1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.C1.tif',
                                  'C2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.C2.tif',
                                  'D1':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.D1.tif',
                                  'D2':FileKeyUtils.BMNG500mStore+'world.topo.bathy.200401.3x21600x10800.D2.tif'}

  for k in _BMNG500mFiles.keys() :
    vimg = VImage.VImage(_BMNG2kmFiles[k]) #; aimg = img.putalpha(255) ; del img
    _BMNG500mVImgs[k] = vimg # aimg
  
  print >> FileKeyUtils.WMSlog, 'Raster.initBMNG500mVImgs>', _BMNG500mVImgs.keys()
  return len(_BMNG500mVImgs)

def is8kmBMNGFile(filename):
  """
  Returns True or False.
  Only checks the filename/substring: full path is not required, no 'stat' or I/O check
  """
  try:
    if filename.index('5400') >= 0 :
      return True
  except: pass

  return False

def is2kmBMNGFile(filename):
  """
  Returns True or False.
  Only checks the filename/substring: full path is not required, no 'stat' or I/O check
  """
  try:
    if filename.index('10800') >= 0 :
      return True
  except: pass

  return False

def is500mBMNGFile(filename):
  """
  Returns True or False.
  Only checks the filename/substring: full path is not required, no 'stat' or I/O check
  """
  try:
    if filename.index('21600') >= 0 :
      return True
  except: pass

  return False

def buffered8kmBMNGPImg(layerOrfile):
  """
  Returns PIL Image object if found in 8km res. global hash dicts. 
  Returns None if not present/initialized. The arg. can be either 8km
  BMNG layername/alias or actual filename.
  """
  global _BMNG8kmFiles
  global _BMNG8kmPImgs
  if len(_BMNG8kmFiles) > 0:
    for l, f in _BMNG8kmFiles.items() :
      if l == layerOrfile and _BMNG8kmPImgs.has_key(l): return _BMNG8kmPImgs[l]
      if f == layerOrfile and _BMNG8kmPImgs.has_key(f): return _BMNG8kmPImgs[f] 

  return None

def buffered2kmBMNGPImg(layerOrfile):
  """
  Returns PIL Image object if found in 2km res. global hash dicts. 
  Returns None if not present/initialized. The arg. can be either 2km
  BMNG layername/alias or actual filename.
  """
  global _BMNG2kmFiles
  global _BMNG2kmPImgs
  if len(_BMNG2kmFiles) > 0:
    for l, f in _BMNG2kmFiles.items() :
      if l == layerOrfile and _BMNG2kmPImgs.has_key(l): return _BMNG2kmPImgs[l]
      if f == layerOrfile and _BMNG2kmPImgs.has_key(f): return _BMNG2kmPImgs[f]

  return None

def bufferedBMNGPImg(layerOrfile, bmngres):
  if bmngres == 'BMNG8km':
    return  buffered8kmBMNGPImg(layerOrfile)
  if bmngres == 'BMNG2km':
    return  buffered2kmBMNGPImg(layerOrfile)
  if bmngres == 'BMNG500m':
    return  buffered500mBMNGPImg(layerOrfile)

  return None

def buffered8kmBMNGVImg(layerOrfile):
  """
  Returns VIPS Image object if found in 8km res. global hash dicts. 
  Returns None if not present/initialized. The arg. can be either 8km
  BMNG layername/alias or actual filename.
  """
  global _BMNG8kmFiles
  global _BMNG8kmVImgs
  if len(_BMNG8kmFiles) > 0:
    for l, f in _BMNG8kmFiles.items() :
      if l == layerOrfile and _BMNG8kmVImgs.has_key(l): return _BMNG8kmVImgs[l]
      if f == layerOrfile and _BMNG8kmVImgs.has_key(f): return _BMNG8kmVImgs[f]

  return None

def buffered2kmBMNGVImg(layerOrfile):
  """
  Returns VIPS Image object if found in 2km res. global hash dicts. 
  Returns None if not present/initialized. The arg. can be either 2km
  BMNG layername/alias or actual filename.
  """
  global _BMNG2kmFiles
  global _BMNG2kmVImgs
  if len(_BMNG2kmFiles) > 0:
    for l, f in _BMNG2kmFiles.items() :
      if l == layerOrfile and _BMNG2kmVImgs.has_key(l): return _BMNG2kmVImgs[l]
      if f == layerOrfile and _BMNG2kmVImgs.has_key(f): return _BMNG2kmVImgs[f]

  return None

def buffered500mBMNGVImg(layerOrfile):
  """
  Returns VIPS Image object if found in 2km res. global hash dicts. 
  Returns None if not present/initialized. The arg. can be either 2km
  BMNG layername/alias or actual filename.
  """
  global _BMNG500mFiles
  global _BMNG500mVImgs
  if len(_BMNG500mFiles) > 0:
    for l, f in _BMNG500mFiles.items() :
      if l == layerOrfile and _BMNG500mVImgs.has_key(l): return _BMNG500mVImgs[l]
      if f == layerOrfile and _BMNG500mVImgs.has_key(f): return _BMNG500mVImgs[f]

  return None

def bufferedBMNGVImg(layerOrfile, bmngres):
  if bmngres == 'BMNG8km':
    return  buffered8kmBMNGVImg(layerOrfile)
  if bmngres == 'BMNG2km':
    return  buffered2kmBMNGVImg(layerOrfile)
  if bmngres == 'BMNG500m':
    return  buffered500mBMNGVImg(layerOrfile)

  return None

def printInfoDoc():
  """
  Printout global _modinfo text, followed by module help().
  """
  global _modinfo
  print  >> FileKeyUtils.WMSlog, _modinfo
  help("Raster")

def openVImgs(spanfiles):
  """Return list of one or more VImage objs. opened from BMNG file(s)."""
  vimgs = {}
      
  for name in spanfiles:
    filename = _BMNGsummer500m + name + '.tif'
    vimgs[name] = VImage.VImage(filename)

  return vimgs
#end openVImgs

def insidebboxdeg(lonlat, bbox):
  """
  Return True if point lon-lat arg. is inside bbox, otherwise return False
  lonlat = [lon. deg., lat. deg.], bbox = [bot-left lon., bot-left lat., top-right lon, top-right lat.] 
  """
  if lonlat[0] >= bbox[0] and lonlat[0] <= bbox[2]:
    if lonlat[1] >= bbox[1] and lonlat[1] <= bbox[3]:
      print  >> FileKeyUtils.WMSlog, 'Raster.insidebboxdeg> lonlat:',lonlat,', bbox:',bbox 
      return True

  return False

def spanFiles(bbox):
  """
  Return list of one or more BMNG file(s) spanned by bbox.
  """
  global _bboxdegdict
  bmngs = []

  for name, quad in _bboxdeglist.items():
    print  >> FileKeyUtils.WMSlog, 'Raster.spanFiles>',name,quad
    latlon = bbox[0:2]
    if insidebboxdeg(latlon, quad): # lower/bottom-left lon-lat within named BMNG quad 
      if not(name in bmngs) : bmngs.append(name)
    latlon = bbox[2:4]
    if insidebboxdeg(latlon, quad): # upper/top-right lon-lat within named BMNG quad
      if not(name in bmngs) : bmngs.append(name)
    latlon = [bbox[0], bbox[3]]
    if insidebboxdeg(latlon, quad): # upper/top-left lon-lat within named BMNG quad
      if not(name in bmngs) : bmngs.append(name)
    latlon = [bbox[2], bbox[1]]
    if insidebboxdeg(latlon, quad): # lower/bottom-right lon-lat within named BMNG quad
      if not(name in bmngs) : bmngs.append(name)

  print  >> FileKeyUtils.WMSlog, 'Raster.spanFiles> BMNG500m files:', bmngs,', bbox:', bbox
  return bmngs
#end spanFiles

def cropVImg(vimg, pixbbox):
  """
  Return new VImage from cropped extraction of larger VImage arg.
  and bbox arg (that is provided in pixel units)
  """
# evaluate upperf-left, xysize info for each extraction/crop area/bbox.
  xyoffset = [int(pixbbox[0]), int(pixbbox[3])]
  xysize = [int(pixbbox[2]-pixbbox[0]), int(pixbbox[1]-pixbbox[3])]
  print  >> FileKeyUtils.WMSlog, 'Raster.cropVImg>',vimg.filename()
  print  >> FileKeyUtils.WMSlog, 'Raster.cropVImg> upper-left pix:', xyoffset, ', [width, height]:', xysize
# VImage crop func:
  vim = vimg.extract_area(xyoffset[0], xyoffset[1], xysize[0], xysize[1])
  return vim

def span1bbox(name, bbox):
  """
  Returns dict. containing single (1) VImage cropped from single BMNG quad. file
  via bbox (that is converted to pixel coords)."
  """
#
  global _bboxdegdict
  global _bboxdeglist
  global _pixdeg
#
  pbox = [0, 0, 0, 0] # pixel coords of bbox
  quadict = _bboxdegdict[name]
  tl = quadict['TL']
  pbox[0] = (bbox[0] - tl[0]) * _pixdeg
  pbox[1] = (tl[1] - bbox[1]) * _pixdeg
  pbox[2] = (bbox[2] - tl[0]) * _pixdeg
  pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# 'C' case results in single item dict:         
  vimdict = openVImgs([name])
  vim = cropVImg(vimdict[name], pbox)
# del vimdict.pop(name)
# vimdict = {'C:'+name:vim} 
  vimdict = {'C':vim} 
  return vimdict

def span2bbox(vimfiles, bbox):
  """
  Returns dict. containing two (2) VImage cropped from the 2 BMNG quad. files
  spanned by the bbox. Dict. keys must indicate orientation of cropped sub-images
  for subsequent merging into one final image (T,B or L,R)
  """
  global _bboxdeglist
  global _bboxdegdict
  global _pixdeg
  global _pixmax
#
  if len(vimfiles) != 2 :
    return None
#  
  if 'A1' in vimfiles and 'A2' in vimfiles : #'T-B'
# expect top (left & right) in A1 and bottom (left & right) in A2
    quadict = _bboxdegdict['A1']
    tl = quadict['TL'] ;
# pbox top portion in A1
    a1pbox = [0, _pixmax, 0, 0] # expect a1pbox[1] == _pixmax
    a1pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    a1pbox[2] = (bbox[2] - tl[0]) * _pixdeg
    a1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# pbox bottom portion in A2  
    quadict = _bboxdegdict['A2']
    tl = quadict['TL'] ;
    a2pbox = [0, 0, 0, 0] # expect a2pbox[3] == 0
    a2pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    a2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    a2pbox[2] = (bbox[2] - tl[0])* _pixdeg
# extract/crop A1-A2 'T-B'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'T':cropVImg(bmngdict['A1'], a1pbox), 'B': cropVImg(bmngdict['A2'], a2pbox)}
#   del bmngdict.pop('A1') ; del bmngdict.pop('A2')
    return vimdict
#  
  if 'A1' in vimfiles and 'B1' in vimfiles : #'L-R'
# expect left (top & bottom) in A1 and right (top & bottom) in B1
# pbox left portion in A1
    quadict = _bboxdegdict['A1']
    tl = quadict['TL'] ;
    a1pbox = [0, 0, _pixmax, 0] # expect a1pbox[1] == _pixmax
    a1pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    a1pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    a1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# pbox right portion in B1
    quadict = _bboxdegdict['B1']
    tl = quadict['TL'] ;
    b1pbox = [0, 0, 0, 0] # expect b1pbox[0] == 0
    b1pbox[2] = (bbox[0] - tl[0]) * _pixdeg
    b1pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    b1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# extract/crop A1-B1 'L-R'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'L':cropVImg(bmngdict['A1'], a1pbox), 'R': cropVImg(bmngdict['B1'], b1pbox)}
#   del bmngdict.pop('A1') ; del bmngdict.pop('B1')
    return vimdict
#
  if 'A2' in vimfiles and 'B2' in vimfiles : #'L-R'
# expect left in A2 and right  in B2
# pbox left portion in A2
    quadict = _bboxdegdict['A2']
    tl = quadict['TL'] ;
    a2pbox = [0, 0, _pixmax, 0] # expect a2pbox[1] == _pixmax
    a2pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    a2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    a2pbox[3] = (tl[3] - bbox[3]) * _pixdeg
# pbox right portion in B2
    quadict = _bboxdegdict['B2']
    tl = quadict['TL'] ;
    b2pbox = [0, 0, 0, 0] # expect b2pbox[0] == 0
    b2pbox[2] = (bbox[0] - tl[0]) * _pixdeg
    b2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    b2pbox[3] = (tl[1] - bbox[3]) * _pixdeg
    bboxdict = {'L:A2':a2pbox, 'R:B2':b2pbox} 
# extract/crop A2-B2 'L-R'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'L':cropVImg(bmngdict['A2'], a2pbox), 'R': cropVImg(bmngdict['B2'], b2pbox)}
#   del bmngdict.pop('A2') ; del bmngdict.pop('B2')
    return vimdict
#   
  if 'B1' in vimfiles and 'B2' in vimfiles : #'T-B'
# expect top in B1 and bottom in B2
    quadict = _bboxdegdict['B1']
    tl = quadict['TL'] ;
# pbox top portion in B1
    b1pbox = [0, _pixmax, 0, 0] # expect b1pbox[1] == _pixmax
    b1pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    b1pbox[2] = (bbox[2] - tl[0]) * _pixdeg
    b1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# pbox bottom portion in B2  
    quadict = _bboxdegdict['B2']
    tl = quadict['TL'] ;
    b2pbox = [0, 0, 0, 0] # expect b2pbox[3] == 0
    b2pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    b2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    b2pbox[2] = (bbox[2] - tl[0])* _pixdeg
# extract/crop B1-B2 'T-B'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'T':cropVImg(bmngdict['B1'], b1pbox), 'B': cropVImg(bmngdict['B2'], b2pbox)}
#   del bmngdict.pop('B1') ; del bmngdict.pop('B2')
    return vimdict
#
  if 'B1' in vimfiles and 'C1' in vimfiles : #'L-R'
# expect left in B1 and right in C1
# pbox left portion in B1
    quadict = _bboxdegdict['B1']
    tl = quadict['TL'] ;
    b1pbox = [0, 0, _pixmax, 0] # expect b1pbox[1] == _pixmax
    b1pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    b1pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    b1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# pbox right portion in C1
    quadict = _bboxdegdict['C1']
    tl = quadict['TL'] ;
    c1pbox = [0, 0, 0, 0] # expect c1pbox[0] == 0
    c1pbox[2] = (bbox[0] - tl[0]) * _pixdeg
    c1pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    c1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# extract/crop B1-C1 'L-R'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'L':cropVImg(bmngdict['B1'], b1pbox), 'R': cropVImg(bmngdict['C1'], c1pbox)}
#   del bmngdict.pop('B1') ; del bmngdict.pop('C1')
    return vimdict
#
  if 'B2' in vimfiles and 'C2' in vimfiles : #'L-R'
# expect left in B2 and right in C2
# pbox left portion in A2
    quadict = _bboxdegdict['B2']
    tl = quadict['TL'] ;
    b2pbox = [0, 0, _pixmax, 0] # expect b2pbox[1] == _pixmax
    b2pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    b2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    b2pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# pbox right portion in C2
    quadict = _bboxdegdict['C2']
    tl = quadict['TL'] ;
    c2pbox = [0, 0, 0, 0] # expect c2pbox[0] == 0
    c2pbox[2] = (bbox[0] - tl[0]) * _pixdeg
    c2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    c2pbox[3] = (tl[3] - bbox[3]) * _pixdeg
# extract/crop B2-C2 'L-R'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'L':cropVImg(bmngdict['B2'], b2pbox), 'R': cropVImg(bmngdict['C2'], c2pbox)}
#   del bmngdict.pop('B2') ; del bmngdict.pop('C2')
    return vimdict
#
  if 'C1' in vimfiles and 'C2' in vimfiles : #'T-B'
# expect top in C1 and bottom in C2
    quadict = _bboxdegdict['C1']
    tl = quadict['TL'] ;
# pbox top portion in C1
    c1pbox = [0, _pixmax, 0, 0] # expect c1pbox[1] == _pixmax
    c1pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    c1pbox[2] = (bbox[2] - tl[0]) * _pixdeg
    c1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# pbox bottom portion in C2  
    quadict = _bboxdegdict['C2']
    tl = quadict['TL'] ;
    c2pbox = [0, 0, 0, 0] # expect c2pbox[3] == 0
    c2pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    c2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    c2pbox[2] = (bbox[2] - tl[0])* _pixdeg
# extract/crop C1-C2 'T-B'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'T':cropVImg(bmngdict['C1'], c1pbox), 'B': cropVImg(bmngdict['C2'], c2pbox)}
#   del bmngdict.pop('C1') ; del bmngdict.pop('C2')
    return vimdict
#
  if 'C1' in vimfiles and 'D1' in vimfiles : #'L-R'
# expect left in C1 and right in D1
# pbox left portion in C1
    quadict = _bboxdegdict['C1']
    tl = quadict['TL'] ;
    c1pbox = [0, 0, _pixmax, 0] # expect c1pbox[1] == _pixmax
    c1pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    c1pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    c1pbox[3] = (tl[3] - bbox[3]) * _pixdeg
# pbox right portion in C1
    quadict = _bboxdegdict['D1']
    tl = quadict['TL'] ;
    d1pbox = [0, 0, 0, 0] # expect d1pbox[0] == 0
    d1pbox[2] = (bbox[0] - tl[0]) * _pixdeg
    d1pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    d1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# extract/crop C1-D1 'L-R'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'L':cropVImg(bmngdict['C1'], c1pbox), 'R': cropVImg(bmngdict['D1'], d1pbox)}
#   del bmngdict.pop('C1') ; del bmngdict.pop('D1')
    return vimdict
#
  if 'C2' in vimfiles and 'D2' in vimfiles : #'L-R'
# expect left in C2 and right in D2
# pbox left portion in C2
    quadict = _bboxdegdict['C2']
    tl = quadict['TL'] ;
    c2pbox = [0, 0, _pixmax, 0] # expect c2pbox[1] == _pixmax
    c2pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    c2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    c2pbox[3] = (tl[3] - bbox[3]) * _pixdeg
# pbox right portion in D2
    quadict = _bboxdegdict['D2']
    tl = quadict['TL'] ;
    d2pbox = [0, 0, 0, 0] # expect d2pbox[0] == 0
    d2pbox[2] = (bbox[0] - tl[0]) * _pixdeg
    d2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    d2pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# extract/crop C2-D2 'L-R'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'L':cropVImg(bmngdict['C2'], c2pbox), 'R': cropVImg(bmngdict['D2'], d2pbox)}
#   del bmngdict.pop('C2') ; del bmngdict.pop('D2')
    return vimdict
#    
  if 'D1' in vimfiles and 'D2' in vimfiles : #'T-B'
# expect top in D1 and bottom in D2
    quadict = _bboxdegdict['D1']
    tl = quadict['TL'] ;
# pbox top portion in D1
    d1pbox = [0, _pixmax, 0, 0] # expect d1pbox[1] == _pixmax
    d1pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    d1pbox[2] = (bbox[2] - tl[0]) * _pixdeg
    d1pbox[3] = (tl[1] - bbox[3]) * _pixdeg
# pbox bottom portion in D2  
    quadict = _bboxdegdict['D2']
    tl = quadict['TL'] ;
    d2pbox = [0, 0, 0, 0] # expect d2pbox[3] == 0
    d2pbox[0] = (bbox[0] - tl[0]) * _pixdeg
    d2pbox[1] = (tl[1] - bbox[1]) * _pixdeg
    d2pbox[2] = (bbox[2] - tl[0])* _pixdeg
# extract/crop D1-D2 'T-B'
    bmngdict = openVImgs(vimfiles)
    vimdict = {'T':cropVImg(bmngdict['D1'], d1pbox), 'B': cropVImg(bmngdict['D2'], d2pbox)}
#   del bmngdict.pop('D1') ; del bmngdict.pop('D2')
    return vimdict

#
# should wrap-dateline be supported?
# if 'D1' in vimfiles and 'A1' in vimfiles : #'L-R'
#
# if 'D2' in vimfiles and 'A2' in vimfiles : #'L-R'
# and if wrapping is supported, how about the poles?
# hum...
  return None
#end span2bbox

def span4bbox(vimfiles, bbox):
  """
  Returns dict. containing four (4) VImage cropped from the 4 BMNG quad. files
  spanned by the bbox. Dict. keys must indicate orientation of cropped sub-images
  for subsequent merging into one final image (TL,BL,TR,BR)
  """
  global _bboxdegdict
  global _bboxdeglist
  global _pixdeg
  global _pixmax
  if len(vimfiles) != 4 :
    return None

  if 'A1' in vimfiles and 'A2' in vimfiles and 'B1' in vimfiles and 'B2' in vimfiles:
# expect top-left tlpbox in A1, top-right trpbox in B1,
# bottom-left blpbox in A2, and bottom-right brpbox in B2
    tlquad = _bboxdegdict['A1']; tl = tlquad['TL']
    tlpbox = [0, _pixmax, _pixmax, 0] # TL:A1
    tlpbox[0] = (bbox[0] - tl[0]) * _pixdeg
    tlpbox[3] = (bbox[3] - tl[1]) * _pixdeg
    trquad = _bboxdegdict['B1'];  tl = trquad['TL']
    trpbox = [0, _pixmax, 0, 0] # TR:B1
    trpbox[2] = (bbox[2] - tl[0]) * _pixdeg
    trpbox[3] = (tl[1] - bbox[3]) * _pixdeg
    blquad = _bboxdegdict['A2']; tl = blquad['TL']
    blpbox = [0, 0, _pixmax, 0] # BL:A2
    blpbox[0] = (bbox[0] - tl[0]) * _pixdeg
    blpbox[3] = (tl[1] - bbox[3]) * _pixdeg
    brquad = _bboxdegdict['B2']; tl = brquad['TL']
    brpbox = [0, 0, 0, 0] # BR:B2
    brpbox[1] = (tl[1] - bbox[1]) * _pixdeg
    brpbox[2] = (bbox[2] - tl[0]) * _pixdeg
#   bboxdict = {'TL:A1':tlpbox, 'TR:B1':trpbox, 'BL:A2':blpbox, 'BR:B2':brpbox}
    bmngdict = openVImgs(vimfiles)
    vimdict = {'TL':cropVImg(bmngdict['A1'], tlpbox), 'TR': cropVImg(bmngdict['B1'], trpbox),
               'BL':cropVImg(bmngdict['A2'], blpbox), 'BR': cropVImg(bmngdict['B2'], brpbox)}
#   del bmngdict.pop('A1'); del bmngdict.pop('A2'); del bmngdict.pop('B1'); del bmngdict.pop('B2')
    return vimdict
#    
  if 'B1' in vimfiles and 'B2' in vimfiles and 'C1' in vimfiles and 'C2' in vimfiles: 
# expect top-left tlpbox in B1, top-right trpbox in C1,
# bottom-left blpbox in B2, and bottom-right brpbox in C2
    tlquad = _bboxdegdict['B1']; tl = tlquad['TL']
    tlpbox = [0, _pixmax, _pixmax, 0] # TL:B1
    tlpbox[0] = (bbox[0] - tl[0]) * _pixdeg
    tlpbox[3] = (bbox[3] - tl[1]) * _pixdeg
    trquad = _bboxdegdict['C1'];  tl = trquad['TL']
    trpbox = [0, _pixmax, 0, 0] # TR:C1
    trpbox[2] = (bbox[2] - tl[0]) * _pixdeg
    trpbox[3] = (tl[1] - bbox[3]) * _pixdeg
    blquad = _bboxdegdict['B2']; tl = blquad['TL']
    blpbox = [0, 0, _pixmax, 0] # BL:B2
    blpbox[0] = (bbox[0] - tl[0]) * _pixdeg
    blpbox[3] = (tl[1] - bbox[3]) * _pixdeg
    brquad = _bboxdegdict['C2']; tl = brquad['TL']
    brpbox = [0, 0, 0, 0] # BR:C2
    brpbox[1] = (tl[1] - bbox[1]) * _pixdeg
    brpbox[2] = (bbox[2] - tl[0]) * _pixdeg#
#   bboxdict = {'TL:B1':tlpbox, 'TR:C1':trpbox, 'BL:B2':blpbox, 'BR:C2':brpbox}
    bmngdict = openVImgs(vimfiles)
    vimdict = {'TL':cropVImg(bmngdict['B1'], tlpbox), 'TR': cropVImg(bmngdict['C1'], trpbox),
               'BL':cropVImg(bmngdict['B2'], blpbox), 'BR': cropVImg(bmngdict['C2'], brpbox)}
#   del bmngdict.pop('B1'); del bmngdict.pop('B2'); del bmngdict.pop('C1'); del bmngdict.pop('C2')
    return vimdict
  
  if 'C1' in vimfiles and 'C2' in vimfiles and 'D1' in vimfiles and 'D2' in vimfiles: 
# expect top-left tlpbox in C1, top-right trpbox in D1,
# bottom-left blpbox in C2, and bottom-right brpbox in D2
    tlquad = _bboxdegdict['C1']; tl = tlquad['TL']
    tlpbox = [0, _pixmax, _pixmax, 0] # TL:C1
    tlpbox[0] = (bbox[0] - tl[0]) * _pixdeg
    tlpbox[3] = (bbox[3] - tl[1]) * _pixdeg
    trquad = _bboxdegdict['D1'];  tl = trquad['TL']
    trpbox = [0, _pixmax, 0, 0] # TR:D1
    trpbox[2] = (bbox[2] - tl[0]) * _pixdeg
    trpbox[3] = (tl[1] - bbox[3]) * _pixdeg
    blquad = _bboxdegdict['C2']; tl = blquad['TL']
    blpbox = [0, 0, _pixmax, 0] # BL:C2
    blpbox[0] = (bbox[0] - tl[0]) * _pixdeg
    blpbox[3] = (tl[1] - bbox[3]) * _pixdeg
    brquad = _bboxdegdict['D2']; tl = brquad['TL']
    brpbox = [0, 0, 0, 0] # BR:D2
    brpbox[1] = (tl[1] - bbox[1]) * _pixdeg
    brpbox[2] = (bbox[2] - tl[0]) * _pixdeg
#   bboxdict = {'TL:C1':tlpbox, 'TR:D1':trpbox, 'BL:C2':blpbox, 'BR:D2':brpbox}
    bmngdict = openVImgs(vimfiles)
    vimdict = {'TL':cropVImg(bmngdict['C1'], tlpbox), 'TR': cropVImg(bmngdict['D1'], trpbox),
               'BL':cropVImg(bmngdict['C2'], blpbox), 'BR': cropVImg(bmngdict['D2'], brpbox)}
#   del bmngdict.pop('D1'); del bmngdict.pop('D2'); del bmngdict.pop('C1'); del bmngdict.pop('C2')
    return vimdict
#
# should wrap-dateline be supported?
# if 'D1' in vimfiles and 'D2' in vimfiles and 'A1' in vimfiles and 'A2' in vimfiles: 
# expect top-left tlpbox in D1, top-right trpbox in A1,
# bottom-left blpbox in D2, and bottom-right brpbox in A2
  return None
#end span4bbox

def mergeVImgs(vimgs):
  """Return single VImage obj. from merger of list, deleting contents of list."""
#
# check for 'pathalogical' dict./container content
  if len(vimgs) <= 0 : return None
  if len(vimgs) == 3 : return None
  if len(vimgs) == 1 :
    name, vim = vimgs.popitem()
    return None

# deal with case of 2:
# try bottom-left
  if len(vimge) == 2 :
    try:
      bl = vimgs.pop('BL')
      if not(bl == None) :
        try:
          br = vimgs.pop('BR')
          if not(br == None) :
            vim = ll.lrmerge(br, ll.Xsize(), 0, 0)
            del bl; del br
            return vim
        except:
          tl = vimgs.pop('TL')
          if not(br == None) :
            vim = tl.tbmerge(bl, 0, tl.Ysize(), 0)
            del bl; del tl
            return vim
    except: pass
# if bottom-left not present, try top-left with top-right
    try:
      tl = vimgs.pop('TL')
      if not(tl == None) :
        try:
          tr = vimgs.pop('TR')
          if not(br == None) :
            vim = tl.lrmerge(br, tl.Xsize(), 0, 0)
            del tl; del tr
            return vim
        except: pass
    except: pass
# only remaining possibility -- try top-right with bottom-right
    try:
      tr = vimgs.pop('TR')
      if not(tl == None) :
        try:
          br = vimgs.pop('BR')
          if not(br == None) :
            vim = tr.tbmerge(br, 0, tr.Ysize(), 0)
            del tr; del br
            return vim
        except: pass
    except: pass
# something is amiss with the 2 item dict.
    return None
# end 2 items
#
# worse case scenario is that bbox spans 4 BMNG 500m files
# the vimgs dict should contain extracted/cropped subimages from
# each file organized by the keyed quadrants

# merge left and right bottom/lower quadrants:
  bl = vimgs.pop('BL') ; br = vimgs.pop('BR')
  bot = bl.lrmerge(br, bl.Xsize(), 0, 0) ; del bl ; del br

# merge left and right top/upper quadrants:
  tl = vimgs.pop('TL') ; tr = vimgs.pop('TR') ; del tl ; del tr
  top = tl.lrmerge(tr, tl.Xsize(), 0, 0)

  vim = top.tbmerge(bot, 0, top.Ysize(), 0) ; del top; del bot

  return vim
#end mergeVImages

def resizeVImg(vim, size):
  """Return resized VImage obj. (generally used after extracting/cropping area of interest)."""
  sz = [vim.Xsize(), vim.Ysize()]
  xscale = 1.0*size[0]/sz[0]
  yscale = 1.0*size[1]/sz[1]
  im = vim.affine(xscale, 0, 0, yscale, 0, 0, 0, 0, size[0], size[1])
# debug:
# png = '/devstore/dhon/may2008/vipilwmsc/tmp/cropvips_'+repr(sz[0])+'x'+repr(sz[1])+'.png'
# vim.write(png)
# print  >> FileKeyUtils.WMSlog, 'Raster.resizeVImg>', png 
# png = '/devstore/dhon/may2008/vipilwmsc/tmp/reszvips_'+repr(size[0])+'x'+repr(size[1])+'_'+repr(sz[0])+'x'+repr(sz[1])+'.png'
# im.write(png)
# print  >> FileKeyUtils.WMSlog, 'Raster.resizeVImg>', png 
  return im

def extractPIL(pimg, bmngres, bbox): # 8km and 2km single-file, single-image
  print >> FileKeyUtils.WMSlog, 'Raster.extractPIL> BMNG resolution, bbox:', bmngres, bbox
  pim = None
  if not(bmngres == 'BMNG2km') and not(bmngres == 'BMNG8km'):
    print >> FileKeyUtils.WMSlog, 'Raster.extractPIL> BMNG resoution problem,', bmngres
    return pim
# if no cropping is required in == out:
# if pimg.size == size:
#   if abs(bbox[0]+180.0) <= 0.0000001:
#     if abs(bbox[1]+90.0) <= 0.0000001:
#       if abs(bbox[2]-180.0) <= 0.0000001:
#         if abs(bbox[3]-90.0) <= 0.0000001:
#           pimg.putalpha(alpha)
#           pimg.save(outfile, 'png')
#           return pimg

# default 8km:
# wbmng = {'BMNG8km':5400, 'BMNG2km':21600, 'BMNG500m':21600}
# hbmng = {'BMNG8km':2700, 'BMNG2km':10800, 'BMNG500m':21600}
# wmax = wbmng['BMNG8km'] ; hmax = hbmng['BMNG8km']
# pix = bmimg.load()
# assume bbox min-max: [-180, -90, 180, 90]
# convert the bbox from degrees to pixels
# try:
#   if rasterfile.index('2km') >= 0:
#     wmax = wbmng['BMNG2km'] ; hmax = hbmng['BMNG2km']
# except: pass
# try:
#   if rasterfile.index('500m') >= 0:
#     wmax = wbmng['BMNG500m'] ; hmax = hbmng['BMNG500m']
# except: pass
#
# or if we can assume pimg is from file of entire globe:
# wmax = pimg.size[0] ; hmax = pimg.size[1]
# wpixdeg = wmax / 360.0
# hpixdeg = hmax / 180.0

  wpixdeg = _Xpixdeg[bmngres]
  hpixdeg = _Ypixdeg[bmngres]
  xleft = int((bbox[0]+180.0) * wpixdeg)
  xright = int((bbox[2]+180.0) * wpixdeg)
  yleft = int((90.0-bbox[1]) * hpixdeg)
  yright = int((90.0-bbox[3]) * hpixdeg)
  if yleft < yright :
    yupper = yleft
    ylower = yright
  else :
    yupper = yright
    ylower = yleft

  cropbox = [xleft, yupper, xright, ylower]
  print >> FileKeyUtils.WMSlog, 'Raster.extractPIL> crop:',cropbox
  try:
    pim = pimg.crop(cropbox)
  except:
    print >> FileKeyUtils.WMSlog, 'Raster.extractPIL> exception/error PIL crop, bbox:', bbox

  return pim

def extractVIPS(vimg, bmngres, bbox): # 8km and 2km single-file, single-image
  print >> FileKeyUtils.WMSlog, 'Raster.extractVIPS> BMNG resolution, bbox:', bmngres, bbox
  vim = None
  if not(bmngres == 'BMNG2km') and not(bmngres == 'BMNG8km'):
    print >> FileKeyUtils.WMSlog, 'Raster.extractVIPS> BMNG resolution problem,', bmngres
    return vim

# strange lat. bbox values from openlayers:
  if bbox[1] < -90.0 or bbox[1] > 90.0:
    print >> FileKeyUtils.WMSlog, 'Raster.extractVIPS> bbox problem,', bbox
    return vim

# strange lat. bbox values from openlayers:
  if bbox[3] < -90.0 or bbox[3] > 90.0:
    print >> FileKeyUtils.WMSlog, 'Raster.extractVIPS> bbox problem,', bbox
    return vim

  wpixdeg = _Xpixdeg[bmngres]
  hpixdeg = _Ypixdeg[bmngres]
  xleft = int((bbox[0]+180.0) * wpixdeg)
  xright = int((bbox[2]+180.0) * wpixdeg)
  yleft = int((90.0-bbox[1]) * hpixdeg)
  yright = int((90.0-bbox[3]) * hpixdeg)
  if yleft < yright :
    yupper = yleft
    ylower = yright
  else :
    yupper = yright
    ylower = yleft

  wcrop = abs(xright-xleft) ; hcrop = abs(yupper-ylower)
  print >> FileKeyUtils.WMSlog, 'Raster.extractVIPS>',xleft, yupper, wcrop, hcrop
  try:
    vim = vimg.extract_area(xleft, yupper, wcrop, hcrop)
  except:
    print >> FileKeyUtils.WMSlog, 'Raster.extractVIPS> exception/error VIPS crop, bbox:', bbox

  return vim

def extractVImgs(bbox): # 500m multi-file, multi-image (that must be mosaic'ed)
  """
  Evaluate and return cropped/extracted pixel images. First evaluate dict. of
  crop-boxes (in pixel coords) for each sub-images in the  list of VImages spanned by bbox:
  bboxdict == {'key==C,L,R,T,B,BL,BR,TL,TR':VImage, ...}
  where keys indicate:
  C bboxdict elem. == bbbox and is fully contained within a single BMNG quad. Q == A1,2 - D1,2
  L bboxdict elem. is left side of left-right pair spanning 2 BMNG quads Qs
  R bboxdict elem. is right side of left-right pair spanning 2 BMNG quads Qs
  T bboxdict elem. is top side of top-bottom pair spanning 2 BMNG quads Qs
  B bboxdict elem. is bottom side of top-bottom pair spanning 2 BMNG quads Qs
  BL bboxdict elem. is bottom-left quadrant of 4 BMNG quad files Qs
  BR bboxdict elem. is bottom-right quadrant of 4 BMNG quad files Qs
  TL bboxdict elem. is top-left quadrant of 4 BMNG quad files Qs
  TR bboxdict elem. is top-right quadrant of 4 BMNG quad files Qs
  """

  vimfiles = spanFiles(bbox)
  
  if len(vimfiles) == 1 : # bbox is fully contained within a single BMNG quad
    return span1bbox(vimfiles[0], bbox)

# note that all pixel coordinates should have the origin (0,0) at top-left...
# test for 'T-B and 'L-R' pairs
  if len(vimfiles) == 2 :
    return span2bbox(vimfiles, bbox)

# final case is the 4 file span...
  if len(vimfiles) == 4:
    return span4bbox(vimfiles, bbox)

# for all other cases, something is amiss.
  return None

# end extractVImgs

def genVImgTile(bbox, size):
  """
  Evaluate and return desired image tile of specified size by cropping and extracting one
  or more sub-images from 1 to 4 BMNG 'quad.' files and merging and resizing them into a
  single images. All intermediate image results are deleted.
  """
  # this converts bbox(s) from lat-lon to pixel coords., opens associated BMNG files,
  # then converts the pixel coord bbox(s) into crop/extract pixel top-left corner
  # and width,height size, and returns newhash dict of cropped/extracted VImaqes:
  extracted = extractVImgs(bbox)
  if extracted == None :
    return None
  if len(extracted) <= 0 :
    return None # failed
  if len(extracted) == 3 :
    return None # failed
  
  if len(extracted) == 1 : # had better be fully contained 'C' within one BMNG quad-file
    if extracted.has_key('C') :
      vim = extracted['C']
    else:
      return None # something is amiss
  else:
    vim = mergeVImages(extracted) # merge 2 or 4 cropped/extracted VImages into 1

  if vim == None :
    return None
  
  tile = resizeVImg(vim, size) ; del vim
  return tile

def testSingle(bmng, size):
  """
  Return image tile extracted from single bmng 500m file (A1 or A2 or B1 ... D2)
  """
  global _bboxdeglist
  bbox = _bboxdeglist[bmng]
  bbox[0] = 0.9 * bbox[0] ; bbox[1] = 0.9 * bbox[1] ; bbox[2] = 0.9 * bbox[2] ; bbox[3] = 0.9 * bbox[3]

  return genVImgTile(bbox, size)

  
def testC(bmngs, size):
  """
  Return image tile extracted from 4 bmng 500m files (A1,A2,B1,B2 or ... C1,D1,C2,D2)
  """
  global _bboxdeglist

  if 'A1' in bmngs and 'A2' in bmngs and 'B1' in bmngs and 'B2' in bmngs:
    blbox = _bboxdeglist['A2']
    trbox = _bboxdeglist['B1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  
  if 'B1' in bmngs and 'B2' in bmngs and 'C1' in bmngs and 'C2' in bmngs:
    blbox = _bboxdeglist['B2']
    trbox = _bboxdeglist['C1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(box, size)

  if 'C1' in bmngs and 'C2' in bmngs and 'D1' in bmngs and 'D2' in bmngs:
    blbox = _bboxdeglist['C2']
    trbox = _bboxdeglist['D1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(box, size)

  return None

def testLR(bmngs, size):
  if 'A1' in bmngs and 'B1' in bmngs:
    blbox = _bboxdeglist['A1']
    trbox = _bboxdeglist['B1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'A2' in bmngs and 'B2' in bmngs:
    blbox = _bboxdeglist['A2']
    trbox = _bboxdeglist['B2']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'B1' in bmngs and 'C1' in bmngs:
    blbox = _bboxdeglist['B1']
    trbox = _bboxdeglist['C1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'B2' in bmngs and 'C2' in bmngs:
    blbox = _bboxdeglist['B2']
    trbox = _bboxdeglist['C2']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'C1' in bmngs and 'D1' in bmngs:
    blbox = _bboxdeglist['C1']
    trbox = _bboxdeglist['D1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'C2' in bmngs and 'D2' in bmngs:
    blbox = _bboxdeglist['C2']
    trbox = _bboxdeglist['D2']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)

  return None

def testTB(bmngs, size):
  if 'A1' in bmngs and 'A2' in bmngs:
    blbox = _bboxdeglist['A2']
    trbox = _bboxdeglist['A1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'B1' in bmngs and 'B2' in bmngs:
    blbox = _bboxdeglist['B2']
    trbox = _bboxdeglist['B1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'C1' in bmngs and 'C2' in bmngs:
    blbox = _bboxdeglist['C2']
    trbox = _bboxdeglist['C1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)
  if 'D1' in bmngs and 'D2' in bmngs:
    blbox = _bboxdeglist['D2']
    trbox = _bboxdeglist['D1']
    bbox = [0.9*blbox[0], 0.9*blbox[1], 0.9*trbox[0], 0.9*trbox[1]]
    return genVImgTile(bbox, size)

  return None
  
if __name__ ==  '__main__' :  
  arg0 = arg = sys.argv.pop(0)
  print  >> FileKeyUtils.WMSlog, arg0
  vim = None
  size = [256, 256]
  bbox = [0.0, 0.0, 0.0, 0.0]
  print  >> FileKeyUtils.WMSlog, 'Raster.singlde quad default test: 1kx1k extracted from C1 center and resized to 256x256...'  
  bbox[0] = _pixmax/2.0 - 512 ; bbox[0] = bbox[0]/_pixdeg
  bbox[1] = _pixmax/2.0 - 512 ; bbox[1] = bbox[1]/_pixdeg
  bbox[2] = _pixmax/2.0 + 512 ; bbox[2] = bbox[2]/_pixdeg
  bbox[3] = _pixmax/2.0 + 512 ; bbox[3] = bbox[3]/_pixdeg 
  print  >> FileKeyUtils.WMSlog, bbox
  
  if len(sys.argv) > 0 :
    arg = sys.argv.pop(0)
    if arg in ['-c1', '-c4', '-tb', '-lr']:
      if arg == '-c1' :
        vim = testSingle('B1', size)
      if arg == '-c4' :
        vim = testC(['A1','A2','B1','B2'], size)
      if arg == '-tb' :
        vim = testC(['B1','B2'], size)
      if arg == '-lr' :
        vim = testC(['B1','C1'], size)
    else:
      bbox[0] = float(sys.argv[0])
  if len(sys.argv) > 0 :
    arg = sys.argv.pop(0)
    bbox[1] = float(arg)
  if len(sys.argv) > 0 :
    arg = sys.argv.pop(0)
    bbox[2] = float(arg)
  if len(sys.argv) > 0 :
    arg = sys.argv.pop(0)
    bbox[3] = float(arg)

  if vim == None :
    vim = genVImgTile(bbox, size)

  if vim == None :
    print  >> FileKeyUtils.WMSlog, 'Raster.no image tile'
    sys.exit(0)
    
  vim.write('tile.png')

